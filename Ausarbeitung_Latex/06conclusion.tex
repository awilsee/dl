\mysection{Conclusion}
At the beginning, a lot of research was done to answer the general question of 'how can a network be integrated in a mobile application and run on a performance critical device'. During the research, Tensorflow Lite was chosen as an API which enables running a network on an Android mobile phone. Because Tensorflow supports the models MobileNet and Inception specifically for mobile application usage, both were chosen. Based on this decision, both models were investigated and a comparison of both of them was incorporated into this work. After determining which framework and models are suitable for mobile applicaton support, the installation began. Because of a good documentation the installation of Tensorflow and its necessary dependencies was done quickly. Following the tutorials the models were retrained on dog images. For a first, the optimization of the models to its full degree was omitted and the focus was to include the optimized models in the mobile application for running. Therefore, Tensorflow Lite was used to convert the .pb file to a .tflite file. The conversion was conducted successfully, but the produced .tflite file caused the app to terminate. After proving the versions of all used APIs and reconverting the models several times, the app still collapsed without throwing an error. Even after optimizing, rounding, quantizing the models with different commands, the app failed to run. In addition, the tutorials and documentation are kept short on this subject. Because of this behaviour, Tensorflow Mobile was used instead of Tensorflow Lite which is still in development mode. After integration of the .pb file and its corresponding label file, the Tensorflow version had to be adapted. If adding '+' in the dependency section for Tensorflow instead of the specified version, Android Studio installs the most recent one. Futhermore, after integrating an InceptionV3 model, no results were displayed while the app was running. Therefore, the threshold was adapted to a lower value in order to display low results from the network. Later, the threshold was set to 0.1f and the models were optimized. Next, the models were optimized to their full degree based on varying the learning rate in relation to the training steps. Afterwards, the models were comprised and loaded into the mobile application. The result are two applications, one including MobileNet and another containing InceptionV3. In the last step, the models were compared based on performance, time expenditure for producing an optimized model and quality in accuracy. Especially for the time related evaluation, marker were placed in the scripts to measure the time needed for creating the bottlenecks, training on images and evaluating an image. The expectation was that the InceptionV3 was the most accurate model, but the one with the most required performance classifying an image in the mobile application. Futhermore, the MobileNet 1.0 was expected to be the most fastest and accurate model, whereas the MobileNet 0.50 might be accurate, but slower than its successor. It turned out contrary to expectations that the MobileNet 0.50 is the most accurate one with lowest performance required (refer to \secref{Evaluation}). As a last surprise, the app was running more smoothly on the Samsung S4 device than on the newer Motorola Moto X which contains a better processor.
\\
\\
\\

- tutorials not complete, different \\
- which model is better \\
- Tensorflow Lite conversion failed completely \\
- prospects, improvements, Recommendations \\
\\
\\ \\
Beispiele fürs referenzieren: \\
In \figref{FH-Logo} ist das HS München Logo zu sehen.

\begin{figure}[htbp]
\includegraphics[width=0.3\textwidth]{includes/MUASlogo}
\caption{FH-Logo}
\label{fig:FH-Logo}
\end{figure}

Oder auch eines Codes wie in  \listref{python_Code}.\\
\begin{lstlisting}[caption=Some python code, label=list:python_Code]

	bottleneck_path_2_bottleneck_values = {}


	def create_bottleneck_file(bottleneck_path, image_lists, label_name, index,
	                           image_dir, category, sess, jpeg_data_tensor,
	                           decoded_image_tensor, resized_input_tensor,
	                           bottleneck_tensor):
	  """Create a single bottleneck file."""
	  tf.logging.info('Creating bottleneck at ' + bottleneck_path)
	  image_path = get_image_path(image_lists, label_name, index,
	                              image_dir, category)
	  if not gfile.Exists(image_path):
	    tf.logging.fatal('File does not exist %s', image_path)
	  image_data = gfile.FastGFile(image_path, 'rb').read()
	  try:
	    bottleneck_values = run_bottleneck_on_image(
	        sess, image_data, jpeg_data_tensor, decoded_image_tensor,
	        resized_input_tensor, bottleneck_tensor)
	  except Exception as e:
	    raise RuntimeError('Error during processing file %s (%s)' % (image_path,
	                                                                 str(e)))
	  bottleneck_string = ','.join(str(x) for x in bottleneck_values)
	  with open(bottleneck_path, 'w') as bottleneck_file:
	    bottleneck_file.write(bottleneck_string)
\end{lstlisting}

Sectionrefs: In \secref{Methodological fundamentals} ist vieles noch nicht fertig. \\
SubSectionrefs: In \subsecref{Common Frameworks for Deep Learning Applications} wird dann näher auf den Inhalt eingegangen.\\
SubSubSectionrefs: In \subsubsecref{Tensorflow based on Python} gehts ans eingemachte.\\

Beispiele fürs zitieren:

Für einen noch besseren Überblick, kann das Buch von \citet{Butler2017} oder auch andere refs wie \citet{CS231nCNN} hinzugezogen werden \citep{Deeplearning4j2017}.\\
Wenn in klammern und Seitenzahl \citep[p. 3]{Butler2017}\\

als compared, aber ohne Seitenzahl \citep[cmp.][]{Butler2017} \\
als compared mit Seitenzahl, das nd heißt "no date", da keine Jahrezahl vorhanden \citep[cmp.][p. 5]{Wang} \\

%Beispiele
%\citet{goossens93} -> Goossens et al. (1993)
%\citep{goossens93} -> (Goossens et al., 1993)
%
%\citet*{goossens93} -> Goossens, Mittlebach, and Samarin (1993)
%\citep*{goossens93} -> (Goossens, Mittlebach, and Samarin, 1993)